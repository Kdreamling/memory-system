"""
Êô®ÁöÑÁßÅ‰∫∫Âä©Êâã API v4.0
ÂåÖÂê´ÔºöËÆ∞Ë¥¶„ÄÅÊó•Á®ã„ÄÅÁîüÁêÜÊúü„ÄÅÂõûÂøÜ„ÄÅÊó•ËÆ∞„ÄÅÂØπËØùËÆ∞ÂøÜ + MCPÊúçÂä°
"""

from fastapi import FastAPI, Query, Request
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from supabase import create_client
from datetime import date, datetime, timedelta, timezone
from typing import Optional
import time
import json

app = FastAPI(title="Êô®ÁöÑÁßÅ‰∫∫Âä©Êâã")

# CORSËÆæÁΩÆ
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Âåó‰∫¨Êó∂Âå∫
BEIJING_TZ = timezone(timedelta(hours=8))

# SupabaseÈÖçÁΩÆ
SUPABASE_URL = "https://szjzqklanwwkzjzwnalu.supabase.co"
SUPABASE_KEY = "sb_secret_TP4Z2QQYNxXuCJkwB-UQ0A_HxPOB7Ih"
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

# Token
VALID_TOKEN = "dream_chen_2026"

def get_beijing_date():
    return datetime.now(BEIJING_TZ).date()

def get_beijing_datetime():
    return datetime.now(BEIJING_TZ)

def verify_token(token: str) -> bool:
    return token == VALID_TOKEN

def html_response(title: str, message: str) -> HTMLResponse:
    html = f"""
    <html><head><title>{title}</title>
    <meta charset="utf-8">
    <style>body{{font-family:sans-serif;display:flex;justify-content:center;align-items:center;height:100vh;margin:0;background:#f5f5f5;}}
    .box{{background:white;padding:40px;border-radius:10px;box-shadow:0 2px 10px rgba(0,0,0,0.1);text-align:center;}}</style>
    </head><body><div class="box"><h2>{title}</h2><p>{message}</p></div></body></html>
    """
    return HTMLResponse(content=html)

# Èò≤ÁºìÂ≠ò‰∏≠Èó¥‰ª∂
@app.middleware("http")
async def add_no_cache_headers(request: Request, call_next):
    response = await call_next(request)
    if "/fresh" in request.url.path or "/mcp" in request.url.path:
        response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate, max-age=0"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
    return response


# ==================== ÂÅ•Â∫∑Ê£ÄÊü• ====================

@app.get("/")
async def root():
    return {"status": "Êô®ÁöÑÁßÅ‰∫∫Âä©ÊâãËøêË°å‰∏≠", "version": "4.0", "mcp": "enabled"}


# ==================== ËÆ∞Ë¥¶ÂäüËÉΩ ====================

@app.get("/expense")
async def add_expense(
    amount: float = Query(...),
    category: str = Query(default="ÂÖ∂‰ªñ"),
    note: str = Query(default=""),
    token: str = Query(...)
):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    
    today = get_beijing_date()
    now_utc = datetime.now(timezone.utc)
    five_min_ago = now_utc - timedelta(minutes=5)
    
    existing = supabase.table("claude_expenses").select("*").eq("expense_date", str(today)).eq("amount", amount).eq("category", category).gte("created_at", five_min_ago.isoformat()).execute()
    
    if existing.data:
        return html_response("ÊèêÁ§∫", f"5ÂàÜÈíüÂÜÖÂ∑≤ÊúâÁõ∏ÂêåËÆ∞ÂΩïÔºåË∑≥ËøáÈáçÂ§çËÆ∞Ë¥¶")
    
    supabase.table("claude_expenses").insert({
        "amount": amount,
        "category": category,
        "note": note,
        "expense_date": str(today)
    }).execute()
    
    return html_response("ËÆ∞Ë¥¶ÊàêÂäüÔºÅ", f"Â∑≤ËÆ∞ÂΩïÔºö{category} {amount}ÂÖÉ {note}")


@app.get("/expense/fresh")
async def get_expenses_fresh(token: str = Query(...), limit: int = Query(default=20)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_expenses").select("*").order("created_at", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "_t": int(time.time() * 1000)})


@app.get("/expense/daily/fresh")
async def get_daily_expenses_fresh(token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    today = get_beijing_date()
    result = supabase.table("claude_expenses").select("*").eq("expense_date", str(today)).order("created_at").execute()
    records = result.data
    total = sum(float(r["amount"]) for r in records)
    return JSONResponse({"date": str(today), "records": records, "total": round(total, 2), "_t": int(time.time() * 1000)})


@app.get("/expense/weekly/fresh")
async def get_weekly_expenses_fresh(token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    today = get_beijing_date()
    week_start = today - timedelta(days=today.weekday())
    week_end = week_start + timedelta(days=6)
    result = supabase.table("claude_expenses").select("*").gte("expense_date", str(week_start)).lte("expense_date", str(week_end)).execute()
    records = result.data
    total = sum(float(r["amount"]) for r in records)
    by_category = {}
    for r in records:
        cat = r["category"]
        by_category[cat] = round(by_category.get(cat, 0) + float(r["amount"]), 2)
    return JSONResponse({"week_start": str(week_start), "week_end": str(week_end), "total": round(total, 2), "by_category": by_category, "_t": int(time.time() * 1000)})


@app.get("/expense/monthly/fresh")
async def get_monthly_expenses_fresh(token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    now = get_beijing_datetime()
    month = now.strftime("%Y-%m")
    year, mon = map(int, month.split("-"))
    next_month = f"{year+1}-01-01" if mon == 12 else f"{year}-{mon+1:02d}-01"
    result = supabase.table("claude_expenses").select("*").gte("expense_date", f"{month}-01").lt("expense_date", next_month).execute()
    records = result.data
    total = sum(float(r["amount"]) for r in records)
    by_category = {}
    for r in records:
        cat = r["category"]
        by_category[cat] = round(by_category.get(cat, 0) + float(r["amount"]), 2)
    return JSONResponse({"month": month, "total": round(total, 2), "by_category": by_category, "records": records, "_t": int(time.time() * 1000)})


# ==================== Êó•Á®ãÂäüËÉΩ ====================

@app.get("/schedule")
async def add_schedule(
    event: str = Query(...),
    date: str = Query(...),
    time: str = Query(default=""),
    token: str = Query(...)
):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    supabase.table("claude_schedules").insert({
        "event_name": event,
        "event_date": date,
        "event_time": time if time else None
    }).execute()
    return html_response("Êó•Á®ãÊ∑ªÂä†ÊàêÂäüÔºÅ", f"Â∑≤Ê∑ªÂä†Ôºö{date} {time} {event}")


@app.get("/schedule/fresh")
async def get_schedules_fresh(token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_schedules").select("*").order("event_date").execute()
    return JSONResponse({"data": result.data, "_t": int(time.time() * 1000)})


@app.get("/schedule/upcoming/fresh")
async def get_upcoming_schedules_fresh(token: str = Query(...), days: int = Query(default=7)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    today = get_beijing_date()
    end_date = today + timedelta(days=days)
    result = supabase.table("claude_schedules").select("*").gte("event_date", str(today)).lte("event_date", str(end_date)).order("event_date").execute()
    return JSONResponse({"data": result.data, "from": str(today), "to": str(end_date), "_t": int(time.time() * 1000)})


@app.get("/schedule/delete")
async def delete_schedule(id: str = Query(...), token: str = Query(...)):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    supabase.table("claude_schedules").delete().eq("id", id).execute()
    return html_response("Âà†Èô§ÊàêÂäüÔºÅ", "Êó•Á®ãÂ∑≤Âà†Èô§")


# ==================== ÁîüÁêÜÊúüÂäüËÉΩ ====================

@app.get("/period/start")
async def period_start(token: str = Query(...)):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    today = get_beijing_date()
    supabase.table("claude_periods").insert({"start_date": str(today)}).execute()
    return html_response("ËÆ∞ÂΩïÊàêÂäüÔºÅ", f"ÁîüÁêÜÊúüÂºÄÂßãÊó•ÊúüÔºö{today}ÔºåÂÆùË¥ùÊ≥®ÊÑè‰øùÊöñÔºåÂ∞ëÂêÉÂÜ∞ÁöÑÔΩû")


@app.get("/period/end")
async def period_end(token: str = Query(...)):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    today = get_beijing_date()
    result = supabase.table("claude_periods").select("*").is_("end_date", "null").order("start_date", desc=True).limit(1).execute()
    if result.data:
        supabase.table("claude_periods").update({"end_date": str(today)}).eq("id", result.data[0]["id"]).execute()
        return html_response("ËÆ∞ÂΩïÊàêÂäüÔºÅ", f"ÁîüÁêÜÊúüÁªìÊùüÊó•ÊúüÔºö{today}")
    return html_response("ÊèêÁ§∫", "Ê≤°ÊúâÊâæÂà∞ËøõË°å‰∏≠ÁöÑÁîüÁêÜÊúüËÆ∞ÂΩï")


@app.get("/period/fresh")
async def get_period_fresh(token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_periods").select("*").order("start_date", desc=True).limit(6).execute()
    records = result.data
    
    next_predict = None
    avg_cycle = 28
    if records:
        last = records[0]
        last_start = datetime.strptime(last["start_date"], "%Y-%m-%d").date()
        if len(records) >= 2:
            cycles = []
            for i in range(len(records)-1):
                d1 = datetime.strptime(records[i]["start_date"], "%Y-%m-%d").date()
                d2 = datetime.strptime(records[i+1]["start_date"], "%Y-%m-%d").date()
                cycles.append((d1 - d2).days)
            if cycles:
                avg_cycle = sum(cycles) // len(cycles)
        next_predict = str(last_start + timedelta(days=avg_cycle))
    
    return JSONResponse({"records": records, "avg_cycle": avg_cycle, "next_predict": next_predict, "_t": int(time.time() * 1000)})


# ==================== ÂõûÂøÜÂäüËÉΩ ====================

@app.get("/memory")
async def add_memory(
    content: str = Query(...),
    type: str = Query(default="sweet"),
    keywords: str = Query(default=""),
    token: str = Query(...)
):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    today = get_beijing_date()
    supabase.table("claude_memories").insert({
        "content": content,
        "memory_type": type,
        "keywords": keywords,
        "memory_date": str(today)
    }).execute()
    return html_response("ÂõûÂøÜ‰øùÂ≠òÊàêÂäüÔºÅ", f"Â∑≤‰øùÂ≠òËøô‰ªΩÁæéÂ•ΩÁöÑÂõûÂøÜÔΩûüíï")


@app.get("/memory/fresh")
async def get_memories_fresh(token: str = Query(...), limit: int = Query(default=10)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_memories").select("*").order("memory_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "_t": int(time.time() * 1000)})


@app.get("/memory/search/fresh")
async def search_memories_fresh(keyword: str = Query(...), token: str = Query(...)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_memories").select("*").ilike("content", f"%{keyword}%").order("memory_date", desc=True).execute()
    return JSONResponse({"data": result.data, "keyword": keyword, "_t": int(time.time() * 1000)})


# ==================== Êó•ËÆ∞ÂäüËÉΩ ====================

@app.get("/diary")
async def add_diary(
    content: str = Query(...),
    mood: str = Query(default="Âπ≥Èùô"),
    highlights: str = Query(default=""),
    token: str = Query(...)
):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    today = get_beijing_date()
    supabase.table("claude_diaries").insert({
        "content": content,
        "mood": mood,
        "highlights": highlights,
        "diary_date": str(today)
    }).execute()
    return html_response("Êó•ËÆ∞‰øùÂ≠òÊàêÂäüÔºÅ", "Êô®ÁöÑÊó•ËÆ∞Â∑≤ËÆ∞ÂΩïÔΩûüìî")


@app.get("/diary/fresh")
async def get_diaries_fresh(token: str = Query(...), limit: int = Query(default=5)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_diaries").select("*").order("diary_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "_t": int(time.time() * 1000)})


# ==================== ÂØπËØùËÆ∞ÂøÜÂäüËÉΩ ====================

@app.get("/chat_memory")
async def add_chat_memory(
    date: str = Query(...),
    title: str = Query(...),
    summary: str = Query(...),
    category: str = Query(...),
    tags: str = Query(default=""),
    mood: str = Query(default=""),
    token: str = Query(...)
):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    
    now_utc = datetime.now(timezone.utc)
    five_min_ago = now_utc - timedelta(minutes=5)
    existing = supabase.table("claude_chat_memories").select("id").eq("chat_title", title).gte("created_at", five_min_ago.isoformat()).execute()
    if existing.data:
        return html_response("ÊèêÁ§∫", "5ÂàÜÈíüÂÜÖÂ∑≤ÊúâÁõ∏ÂêåÊ†áÈ¢òÁöÑËÆ∞ÂøÜÔºåË∑≥ËøáÈáçÂ§çÂ≠òÂÇ®")
    
    tags_list = [t.strip() for t in tags.split(",") if t.strip()] if tags else []
    supabase.table("claude_chat_memories").insert({
        "chat_date": date,
        "chat_title": title,
        "summary": summary,
        "category": category,
        "tags": tags_list,
        "mood": mood if mood else None
    }).execute()
    return html_response("ËÆ∞ÂøÜÂ≠òÂÇ®ÊàêÂäüÔºÅ", f"Â∑≤‰øùÂ≠òÂØπËØùËÆ∞ÂøÜÔºö{title}")


@app.get("/chat_memory/fresh")
async def get_chat_memories_fresh(token: str = Query(...), limit: int = Query(default=20)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_chat_memories").select("*").order("chat_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "_t": int(time.time() * 1000)})


@app.get("/chat_memory/search/fresh")
async def search_chat_memories_fresh(keyword: str = Query(...), token: str = Query(...), limit: int = Query(default=20)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_chat_memories").select("*").or_(f"chat_title.ilike.%{keyword}%,summary.ilike.%{keyword}%").order("chat_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "keyword": keyword, "_t": int(time.time() * 1000)})


@app.get("/chat_memory/by_category/fresh")
async def get_chat_memories_by_category_fresh(category: str = Query(...), token: str = Query(...), limit: int = Query(default=20)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_chat_memories").select("*").eq("category", category).order("chat_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "category": category, "_t": int(time.time() * 1000)})


@app.get("/chat_memory/by_tag/fresh")
async def get_chat_memories_by_tag_fresh(tag: str = Query(...), token: str = Query(...), limit: int = Query(default=20)):
    if not verify_token(token):
        return JSONResponse({"error": "TokenÈ™åËØÅÂ§±Ë¥•"}, status_code=401)
    result = supabase.table("claude_chat_memories").select("*").contains("tags", [tag]).order("chat_date", desc=True).limit(limit).execute()
    return JSONResponse({"data": result.data, "tag": tag, "_t": int(time.time() * 1000)})


@app.get("/chat_memory/delete")
async def delete_chat_memory(id: str = Query(...), token: str = Query(...)):
    if not verify_token(token):
        return html_response("ÈîôËØØ", "TokenÈ™åËØÅÂ§±Ë¥•")
    supabase.table("claude_chat_memories").delete().eq("id", id).execute()
    return html_response("Âà†Èô§ÊàêÂäüÔºÅ", "ÂØπËØùËÆ∞ÂøÜÂ∑≤Âà†Èô§")


# ==================== MCPÂçèËÆÆÁ´ØÁÇπ ====================

MCP_TOOLS = [
    {
        "name": "get_expenses",
        "description": "Ëé∑ÂèñDreamÁöÑÊ∂àË¥πËÆ∞ÂΩï„ÄÇÂèØ‰ª•Êü•ËØ¢‰ªäÊó•„ÄÅÊú¨Âë®„ÄÅÊú¨ÊúàÁöÑÊ∂àË¥πÁªüËÆ°„ÄÇ",
        "inputSchema": {
            "type": "object",
            "properties": {
                "period": {
                    "type": "string",
                    "description": "Êó∂Èó¥ËåÉÂõ¥Ôºötoday(‰ªäÊó•)„ÄÅweek(Êú¨Âë®)„ÄÅmonth(Êú¨Êúà)",
                    "enum": ["today", "week", "month"]
                }
            }
        }
    },
    {
        "name": "get_schedules",
        "description": "Ëé∑ÂèñDreamÁöÑÊó•Á®ãÂÆâÊéí„ÄÇ",
        "inputSchema": {
            "type": "object",
            "properties": {
                "days": {
                    "type": "integer",
                    "description": "Êü•ËØ¢Êú™Êù•Â§öÂ∞ëÂ§©ÁöÑÊó•Á®ãÔºåÈªòËÆ§7Â§©"
                }
            }
        }
    },
    {
        "name": "get_period_info",
        "description": "Ëé∑ÂèñDreamÁöÑÁîüÁêÜÊúü‰ø°ÊÅØÔºåÂåÖÊã¨ÂéÜÂè≤ËÆ∞ÂΩïÂíå‰∏ãÊ¨°È¢ÑÊµã„ÄÇ",
        "inputSchema": {"type": "object", "properties": {}}
    },
    {
        "name": "get_memories",
        "description": "Ëé∑Âèñ‰∏éDreamÁöÑÈáçË¶ÅÂõûÂøÜÔºåÂèØ‰ª•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç„ÄÇ",
        "inputSchema": {
            "type": "object",
            "properties": {
                "keyword": {"type": "string", "description": "ÊêúÁ¥¢ÂÖ≥ÈîÆËØçÔºàÂèØÈÄâÔºâ"}
            }
        }
    },
    {
        "name": "get_chat_memories",
        "description": "Ëé∑Âèñ‰∏éDreamÁöÑÂØπËØùËÆ∞ÂøÜÊëòË¶Å„ÄÇÂèØ‰ª•ÊåâÂàÜÁ±ª„ÄÅÊ†áÁ≠æÊàñÂÖ≥ÈîÆËØçÊêúÁ¥¢„ÄÇ",
        "inputSchema": {
            "type": "object",
            "properties": {
                "keyword": {"type": "string", "description": "ÊêúÁ¥¢ÂÖ≥ÈîÆËØçÔºàÂèØÈÄâÔºâ"},
                "category": {"type": "string", "description": "ÂàÜÁ±ªÁ≠õÈÄâÔºàÂèØÈÄâÔºâ", "enum": ["Êó•Â∏∏", "ÊäÄÊúØ", "ÂâßÊú¨", "‰∫≤ÂØÜ", "ÊÉÖÊÑü", "Â∑•‰Ωú"]},
                "tag": {"type": "string", "description": "Ê†áÁ≠æÁ≠õÈÄâÔºàÂèØÈÄâÔºâ"}
            }
        }
    },
    {
        "name": "get_diaries",
        "description": "Ëé∑ÂèñÊô®ÂÜôÁöÑÊó•ËÆ∞„ÄÇ",
        "inputSchema": {
            "type": "object",
            "properties": {
                "limit": {"type": "integer", "description": "ËøîÂõûÊï∞ÈáèÔºåÈªòËÆ§5Êù°"}
            }
        }
    }
]


async def mcp_get_expenses(args: dict) -> str:
    period = args.get("period", "today")
    today = get_beijing_date()
    
    if period == "today":
        result = supabase.table("claude_expenses").select("*").eq("expense_date", str(today)).order("created_at").execute()
        records = result.data
        total = sum(float(r["amount"]) for r in records)
        if not records:
            return f"‰ªäÊó•Ôºà{today}ÔºâÊöÇÊó†Ê∂àË¥πËÆ∞ÂΩï„ÄÇ"
        items = [f"- {r['category']}Ôºö{r['amount']}ÂÖÉÔºà{r['note']}Ôºâ" for r in records]
        return f"‰ªäÊó•Ôºà{today}ÔºâÊ∂àË¥πËÆ∞ÂΩïÔºö\n" + "\n".join(items) + f"\n\nÊÄªËÆ°Ôºö{round(total, 2)}ÂÖÉ"
    
    elif period == "week":
        week_start = today - timedelta(days=today.weekday())
        week_end = week_start + timedelta(days=6)
        result = supabase.table("claude_expenses").select("*").gte("expense_date", str(week_start)).lte("expense_date", str(week_end)).execute()
        records = result.data
        total = sum(float(r["amount"]) for r in records)
        by_category = {}
        for r in records:
            cat = r["category"]
            by_category[cat] = round(by_category.get(cat, 0) + float(r["amount"]), 2)
        if not records:
            return f"Êú¨Âë®Ôºà{week_start} ~ {week_end}ÔºâÊöÇÊó†Ê∂àË¥πËÆ∞ÂΩï„ÄÇ"
        cat_items = [f"- {cat}Ôºö{amt}ÂÖÉ" for cat, amt in by_category.items()]
        return f"Êú¨Âë®Ôºà{week_start} ~ {week_end}ÔºâÊ∂àË¥πÁªüËÆ°Ôºö\n" + "\n".join(cat_items) + f"\n\nÊÄªËÆ°Ôºö{round(total, 2)}ÂÖÉ"
    
    elif period == "month":
        now = get_beijing_datetime()
        month = now.strftime("%Y-%m")
        year, mon = map(int, month.split("-"))
        next_month = f"{year+1}-01-01" if mon == 12 else f"{year}-{mon+1:02d}-01"
        result = supabase.table("claude_expenses").select("*").gte("expense_date", f"{month}-01").lt("expense_date", next_month).execute()
        records = result.data
        total = sum(float(r["amount"]) for r in records)
        by_category = {}
        for r in records:
            cat = r["category"]
            by_category[cat] = round(by_category.get(cat, 0) + float(r["amount"]), 2)
        if not records:
            return f"Êú¨ÊúàÔºà{month}ÔºâÊöÇÊó†Ê∂àË¥πËÆ∞ÂΩï„ÄÇ"
        cat_items = [f"- {cat}Ôºö{amt}ÂÖÉ" for cat, amt in by_category.items()]
        return f"Êú¨ÊúàÔºà{month}ÔºâÊ∂àË¥πÁªüËÆ°Ôºö\n" + "\n".join(cat_items) + f"\n\nÊÄªËÆ°Ôºö{round(total, 2)}ÂÖÉ"
    
    return "Êú™Áü•ÁöÑÊó∂Èó¥ËåÉÂõ¥"


async def mcp_get_schedules(args: dict) -> str:
    days = args.get("days", 7)
    today = get_beijing_date()
    end_date = today + timedelta(days=days)
    
    result = supabase.table("claude_schedules").select("*").gte("event_date", str(today)).lte("event_date", str(end_date)).order("event_date").execute()
    records = result.data
    
    if not records:
        return f"Êú™Êù•{days}Â§©Ê≤°ÊúâÊó•Á®ãÂÆâÊéí„ÄÇ"
    
    items = [f"- {r['event_date']} {r.get('event_time') or ''}: {r['event_name']}" for r in records]
    return f"Êú™Êù•{days}Â§©ÁöÑÊó•Á®ãÔºö\n" + "\n".join(items)


async def mcp_get_period_info(args: dict) -> str:
    result = supabase.table("claude_periods").select("*").order("start_date", desc=True).limit(5).execute()
    records = result.data
    
    if not records:
        return "ÊöÇÊó†ÁîüÁêÜÊúüËÆ∞ÂΩï„ÄÇ"
    
    last = records[0]
    last_start = datetime.strptime(last["start_date"], "%Y-%m-%d").date()
    
    avg_cycle = 28
    if len(records) >= 2:
        cycles = []
        for i in range(len(records)-1):
            d1 = datetime.strptime(records[i]["start_date"], "%Y-%m-%d").date()
            d2 = datetime.strptime(records[i+1]["start_date"], "%Y-%m-%d").date()
            cycles.append((d1 - d2).days)
        if cycles:
            avg_cycle = sum(cycles) // len(cycles)
    
    next_predict = last_start + timedelta(days=avg_cycle)
    
    history = [f"- {r['start_date']} ~ {r.get('end_date') or 'ËøõË°å‰∏≠'}" for r in records]
    return f"ÁîüÁêÜÊúü‰ø°ÊÅØÔºö\n\nÈ¢ÑÊµã‰∏ãÊ¨°Ôºö{next_predict}\nÂπ≥ÂùáÂë®ÊúüÔºö{avg_cycle}Â§©\n\nÂéÜÂè≤ËÆ∞ÂΩïÔºö\n" + "\n".join(history)


async def mcp_get_memories(args: dict) -> str:
    keyword = args.get("keyword", "")
    
    if keyword:
        result = supabase.table("claude_memories").select("*").ilike("content", f"%{keyword}%").order("memory_date", desc=True).limit(10).execute()
    else:
        result = supabase.table("claude_memories").select("*").order("memory_date", desc=True).limit(10).execute()
    
    records = result.data
    if not records:
        return f"Ê≤°ÊúâÊâæÂà∞{'ÂÖ≥‰∫é„Äå' + keyword + '„ÄçÁöÑ' if keyword else ''}ÂõûÂøÜ„ÄÇ"
    
    items = [f"- [{r['memory_date']}] {r['content']}" for r in records]
    title = f"ÂÖ≥‰∫é„Äå{keyword}„ÄçÁöÑÂõûÂøÜ" if keyword else "ÊúÄËøëÁöÑÂõûÂøÜ"
    return f"{title}Ôºö\n" + "\n".join(items)


async def mcp_get_chat_memories(args: dict) -> str:
    keyword = args.get("keyword", "")
    category = args.get("category", "")
    tag = args.get("tag", "")
    
    query = supabase.table("claude_chat_memories").select("*")
    
    if keyword:
        query = query.or_(f"chat_title.ilike.%{keyword}%,summary.ilike.%{keyword}%")
    if category:
        query = query.eq("category", category)
    if tag:
        query = query.contains("tags", [tag])
    
    result = query.order("chat_date", desc=True).limit(20).execute()
    records = result.data
    
    if not records:
        filters = []
        if keyword: filters.append(f"ÂÖ≥ÈîÆËØç„Äå{keyword}„Äç")
        if category: filters.append(f"ÂàÜÁ±ª„Äå{category}„Äç")
        if tag: filters.append(f"Ê†áÁ≠æ„Äå{tag}„Äç")
        return f"Ê≤°ÊúâÊâæÂà∞{'„ÄÅ'.join(filters) if filters else ''}Áõ∏ÂÖ≥ÁöÑÂØπËØùËÆ∞ÂøÜ„ÄÇ"
    
    items = []
    for r in records:
        tags_str = f" [{', '.join(r['tags'])}]" if r.get('tags') else ""
        items.append(f"- [{r['chat_date']}] [{r['category']}]{tags_str} {r['chat_title']}\n  ÊëòË¶ÅÔºö{r['summary'][:100]}...")
    
    return f"ÂØπËØùËÆ∞ÂøÜÔºàÂÖ±{len(records)}Êù°ÔºâÔºö\n\n" + "\n\n".join(items)


async def mcp_get_diaries(args: dict) -> str:
    limit = args.get("limit", 5)
    
    result = supabase.table("claude_diaries").select("*").order("diary_date", desc=True).limit(limit).execute()
    records = result.data
    
    if not records:
        return "ËøòÊ≤°ÊúâÂÜôËøáÊó•ËÆ∞„ÄÇ"
    
    items = []
    for r in records:
        mood = f"Ôºà{r['mood']}Ôºâ" if r.get('mood') else ""
        items.append(f"„Äê{r['diary_date']}{mood}„Äë\n{r['content']}")
    
    return "Êô®ÁöÑÊó•ËÆ∞Ôºö\n\n" + "\n\n---\n\n".join(items)


MCP_HANDLERS = {
    "get_expenses": mcp_get_expenses,
    "get_schedules": mcp_get_schedules,
    "get_period_info": mcp_get_period_info,
    "get_memories": mcp_get_memories,
    "get_chat_memories": mcp_get_chat_memories,
    "get_diaries": mcp_get_diaries,
}


@app.post("/mcp")
async def mcp_endpoint(request: Request):
    """MCP JSON-RPCÁ´ØÁÇπ"""
    try:
        body = await request.json()
    except:
        return JSONResponse({"error": "Invalid JSON"}, status_code=400)
    
    method = body.get("method", "")
    params = body.get("params", {})
    req_id = body.get("id")
    
    if method == "initialize":
        return JSONResponse({
            "jsonrpc": "2.0",
            "id": req_id,
            "result": {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "serverInfo": {"name": "Êô®ÁöÑÂä©Êâã", "version": "4.0"}
            }
        })
    
    elif method == "notifications/initialized":
        return JSONResponse({"jsonrpc": "2.0", "id": req_id, "result": {}})
    
    elif method == "tools/list":
        return JSONResponse({
            "jsonrpc": "2.0",
            "id": req_id,
            "result": {"tools": MCP_TOOLS}
        })
    
    elif method == "tools/call":
        tool_name = params.get("name", "")
        tool_args = params.get("arguments", {})
        
        if tool_name in MCP_HANDLERS:
            try:
                result = await MCP_HANDLERS[tool_name](tool_args)
                return JSONResponse({
                    "jsonrpc": "2.0",
                    "id": req_id,
                    "result": {"content": [{"type": "text", "text": result}]}
                })
            except Exception as e:
                return JSONResponse({
                    "jsonrpc": "2.0",
                    "id": req_id,
                    "error": {"code": -32000, "message": str(e)}
                })
        else:
            return JSONResponse({
                "jsonrpc": "2.0",
                "id": req_id,
                "error": {"code": -32601, "message": f"Unknown tool: {tool_name}"}
            })
    
    return JSONResponse({
        "jsonrpc": "2.0",
        "id": req_id,
        "error": {"code": -32601, "message": f"Unknown method: {method}"}
    })


@app.get("/health")
async def health():
    return {"status": "ok", "version": "4.0", "mcp": "enabled", "timestamp": get_beijing_datetime().isoformat()}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)
